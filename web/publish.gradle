/*
 * JustEnoughPublishing: automaticlly publish minecraft mods to CurseForge and Github Releases
 * LICENSE : Public Domain, https://creativecommons.org/publicdomain/zero/1.0
 * AUTHOR  : LukeGrahamLandry#6888
 * SOURCE  : https://moddingtutorials.org/publish.gradle
 *
 * Usage:
 * 1. import this script (bottom of build.gradle)
 *    apply from: "https://moddingtutorials.org/publish.gradle"
 * 2. create the config file .github/publish.json as specified bellow
 * 3. define your api keys as environment variables and make sure you expose the required gradle properties
 * 4. create a github action to run `./gradlew publishMod` whenever you want to publish a new version
 *
 * Structure of the config file (location options in order: {root}/.github/publish.json > {subproject}/publish.json > {root}/publish.json):
 * - versions: array of supported minecraft versions. ie ["1.19.3", "1.19.2"]
 * - loader: "forge" or "fabric"
 * - changelogUrl: url will be added to description body
 * - releaseType: default "release", could also be "beta" or "alpha"
 * - github: (optional)
 *      - repo: the name of the repository to release to
 *      - owner: the name of the github account that owns repo
 *      - branch: the name of the branch this release is based on
 * - curseforge: (optional)
 *      - id: the id of the project to publish the file (as a string)
 *
 * Required gradle.properties variables:
 * - version
 * - archives_base_name
 *
 * Environment variables: (can also be set in USER_HOME_FOLDER/.gradle/gradle.properties)
 * - CURSEFORGE_API_KEY: https://authors.curseforge.com/account/api-tokens
 * - GH_API_KEY: personal token with repo permissions https://github.com/settings/tokens
 */

buildscript {
    repositories {
        mavenCentral()
        gradlePluginPortal()
        maven { url "https://maven.architectury.dev" }
    }
    dependencies {
        classpath 'com.google.code.gson:gson:2.8.2'

        classpath "me.shedaniel.unified-publishing:me.shedaniel.unified-publishing.gradle.plugin:0.1.10"
        classpath "com.matthewprenger.cursegradle:com.matthewprenger.cursegradle.gradle.plugin:1.4.0"
        classpath "com.github.breadmoirai.github-release:com.github.breadmoirai.github-release.gradle.plugin:2.4.1"
    }
}

import java.nio.charset.StandardCharsets
import java.nio.file.Files
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException

//////// START DEPENDENCY PLUGINS ////////////

// seems like i cant apply plugins that i added to buildscript classpath by id
// so instead have to import the plugin class and apply it that way
// but unifiedpublishing tries to apply com.matthewprenger.cursegradle by id
// which i can't do so i have my own wrapper plugin that adds their extension and task without trying to apply the dependency

import me.shedaniel.unifiedpublishing.UnifiedPublishingExtension;
import com.matthewprenger.cursegradle.CurseGradlePlugin
import com.github.breadmoirai.githubreleaseplugin.GithubReleasePlugin

class UnifiedPublishingWrapper implements Plugin<Project> {
    void apply(Project project) {
        Task task = project.getTasks().maybeCreate("publishUnified")
        project.afterEvaluate(proj -> proj.getExtensions().getByType(UnifiedPublishingExtension.class).onConfigure(proj, task))
        project.getExtensions().create("unifiedPublishing", UnifiedPublishingExtension.class, project)
    }
}

apply plugin: UnifiedPublishingWrapper
apply plugin: CurseGradlePlugin
apply plugin: GithubReleasePlugin

//////// END DEPENDENCY PLUGINS ////////////


class JustEnoughPublishing {
    class CurseforgePublishConfig {
        String id;
    }

    class GithubPublishConfig {
        String owner;
        String repo;
        String branch;
    }

    class PublishConfig {
        CurseforgePublishConfig curseforge = null;
        GithubPublishConfig github = null;
        String loader;
        String changelogUrl;
        String[] mc_versions;
        String releaseType = "release"
    }

    PublishConfig config;
    String prettyName;
    String cfToken;
    String ghToken;

    Project parentProject
    JustEnoughPublishing(Project parentProject) {
        this.parentProject = parentProject
        this.config = this.loadConfig();
        if (this.config == null) return;
        this.prettyName = this.parentProject.archives_base_name + " " + this.parentProject.version + " " + this.config.loader

        if (this.config.curseforge != null) this.curseforge();
        if (this.config.github != null) this.github()
    }

    void log(String s){
        println "[JustEnoughPublishing] " + s
    }

    PublishConfig loadConfig(){
        List<File> configLocations = [new File(new File(this.parentProject.rootDir, ".github"), "publish.json"), new File(this.parentProject.projectDir, "publish.json"), new File(this.parentProject.rootDir, "publish.json")]

        File dataFile;
        for (int i=0;i<configLocations.size();i++){
            dataFile = configLocations.get(i);
            this.log("checking config file: " + dataFile.toString())
            if (dataFile.exists()) break
            else dataFile = null;
        }
        if (dataFile == null){
            this.log("Missing config file")
            return null;
        }

        List<String> lines = Files.readAllLines(dataFile.toPath(), StandardCharsets.UTF_8);
        String data = String.join("\n", lines);
        Gson GSON = (new GsonBuilder()).setPrettyPrinting().disableHtmlEscaping().create();
        try {
            this.config = GSON.fromJson(data, PublishConfig.class);
        } catch (JsonSyntaxException e){
            e.printStackTrace();
            this.log("Failed to parse config file: " + dataFile.toString() + "\n" + data);
            return null;
        }

        if (this.config.mc_versions == null || this.config.loader == null || this.config.changelogUrl == null){
            this.log("Config requires keys 'mc_versions', 'loader', 'changelogUrl'. will not publish mod.");
            return null;
        }

        this.cfToken = this.parentProject.findProperty("CURSEFORGE_API_KEY") ?: System.getenv("CURSEFORGE_API_KEY")
        if (this.config.curseforge == null){
            this.log("Missing key 'curseforge' in config, will not publish to curseforge.");
        } else if (this.cfToken == null){
            this.log("Missing env variable CURSEFORGE_API_KEY, will not publish to curseforge.");
            this.config.curseforge = null;
        } else if (this.config.curseforge.id == null){
            this.log("Config[curseforge] requires key 'id. will not publish to curseforge.");
            this.config.curseforge = null;
        }

        this.ghToken = this.parentProject.findProperty("GH_API_KEY") ?: System.getenv("GH_API_KEY")
        if (this.config.github == null){
            this.log("Missing key 'github' in config. will not publish to github.");
        } else if (this.ghToken == null){
            this.config.github = null;
            this.log("Missing env variable GH_API_KEY, will not publish to github.");
        } else if (this.config.github.repo == null || this.config.github.branch == null || this.config.github.owner == null){
            this.log("Config[github] requires keys 'repo', 'owner', 'branch'. will not publish to github.");
            this.config.github = null;
        }

        if (this.config.github == null && this.config.curseforge == null){
            this.log("No valid publishing targets")
            return null;
        }

        return this.config;
    }


    // https://github.com/shedaniel/unified-publishing
    // gradlew publishUnified
    void curseforge(){
       this.parentProject.unifiedPublishing {
            project {
                releaseType = this.config.releaseType
                displayName = this.prettyName
                version = this.parentProject.version
                changelog = "See ${this.config.changelogUrl} for full details"
                gameVersions = List.of(this.config.mc_versions)
                gameLoaders = [this.config.loader]

                mainPublication this.parentProject.tasks.remapJar

                curseforge {
                    token = cfToken
                    id = this.config.curseforge.id
                }
            }
        }
    }

    void github(){
        String changelogInfo = """See ${this.config.changelogUrl} for full details.  \nSupported MC Versions: **${String.join(", ", this.config.mc_versions)}**  \nSupported Mod Loader: **${this.config.loader}**  \n"""

        this.parentProject.githubRelease {
            token this.ghToken
            owner this.config.github.owner
            repo this.config.github.repo
            tagName this.parentProject.version
            targetCommitish this.config.github.branch
            releaseName this.prettyName
            body changelogInfo
            generateReleaseNotes false
            draft false
            releaseAssets this.parentProject.remapJar.archiveFile
            allowUploadToExisting false
            overwrite false
            apiEndpoint "https://api.github.com"
            client
        }
    }
}

class JustEnoughPublishingPlugin implements Plugin<Project> {
    void apply(Project project){
        JustEnoughPublishing publisher = new JustEnoughPublishing(project)
        if (publisher.config == null) return;

        project.tasks.register("publishMod") {
            dependsOn(project.tasks.build)

            List<String> targets = new ArrayList<>();
            if (publisher.config.curseforge != null) {
                finalizedBy(project.tasks.publishUnified)
                targets.add("curseforge")
            }
            if (publisher.config.github != null) {
                finalizedBy(project.tasks.githubRelease)
                targets.add("github")
            }
            publisher.log("active targets: " + String.join(", ", targets))
        }

        publisher.log("registered gradle task: publishMod")
    }
}

apply plugin: JustEnoughPublishingPlugin

// TODO: modrinth support, maven support